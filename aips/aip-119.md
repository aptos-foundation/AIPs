---
aip: (this is determined by the AIP Manager, leave it empty when drafting)
title: Scheduled Transactions
author: Manu Dhundi (https://github.com/manudhundi) & Zekun Li (https://github.com/zekun000)
discussions-to (*optional):
Status: Draft
last-call-end-date (*optional):
type: Core, Framework
created: 04/15/2025
updated (*optional):
requires (*optional): <AIP number(s)>
---

# AIP-119 - Scheduled Transactions
  
(Please give a temporary file name to your AIP when first drafting it, such as `aip-x.md`. The AIP manager will assign a number to it after reviewing.)

(Please remove the questions in the "quote box". Provide complete context to the questions being asked in the content that you provide.)

## Summary
A scheduled transaction is a user-submitted transaction that specifies another transaction to be executed at a future time. The system executes it in a suitable future block.  
 
This AIP proposes framework changes to support scheduling, gas handling, and deposits for scheduling future transactions. It also introduces core changes for the blockchain to check at every block for ready scheduled transactions, prioritize them alongside others based on gas fees and existing rules, and execute them accordingly.

### Out of scope
 * Privacy
 * Event based triggers
 * Failure Retries
 * Future execution gas markets
 * Deterministic slicing

## High-level Overview
Framework provides a mechanism that enables users to schedule transactions for future execution programmatically. Users can submit a scheduling transaction specifying a target function, a future execution time (in milliseconds), the maximum gas they’re willing to spend, and the price per gas unit. An optional rescheduling delta can be included to enable recurring scheduling. To prevent denial-of-service or spam, users must deposit the full gas budget up front, which is held in a dedicated fungible asset store. Users may cancel scheduled transactions at any time before execution to reclaim their deposit.

Once submitted, scheduled transactions are stored in a queue data structure sorted by execution time, with 100ms granularity (the order of expected block intervals). At the beginning of each block, the blockchain core system checks whether any scheduled transactions are due. If so, they are considered as candidate transactions and prioritized using specified price per gas unit and existing rules like say, [use case aware block reordering](#https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-68.md). Transactions that are not selected for execution are retried in future blocks, up to a fixed expiration window (around 100 blocks). 

When a scheduled transaction is executed successfully, the actual gas fee is computed and deducted from the deposit. Since it is impractical for users to predict the optimal gas price in advance, they provide a max_gas_unit_price. The system uses the lesser of this maximum and the highest gas price of any transaction in the block, ensuring fairly prioritized inclusion without excessive overpayment. Any unused portion of the deposit is refunded to the user. Additionally, if the transaction specifies a reschedule_delta_time, it is rescheduled to run again after the given interval, supporting periodic task execution.

This approach leverages existing transaction and gas accounting infrastructure, ensures fair prioritization alongside regular transactions, deters misuse via prepaid gas deposits, and creates a foundation for more advanced onchain flows.

## Impact
This is a new feature that provides composability across time. It creates a foundation for more advanced onchain flows like delayed payments, subscriptions, time shifted computations, recurring tasks, async programming patterns, and mission-critical operations that demand sub-millisecond precision — all executed within the deterministic environment of the Aptos blockchain.

Depends on [AIP-112](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-112.md) (Function Values in the Move VM), [AIP-103](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-103.md) (Permissioned signer), Execution pool, FA migration ??

## Alternative Solutions
Storing scheduled transactions off-chain is one alternative. However, it introduces several drawbacks that make it a less viable alternative to on-chain scheduling. It requires maintaining additional infrastructure, leading to increased operational complexity, higher costs, and potential service fees if run by third parties. Guaranteeing data consistency and correctness across nodes becomes difficult, and there are inherent trust and custody risks in delegating execution authority to external systems. This setup also fragments the developer and user experience, as scheduled transactions may not appear in standard APIs or explorers, complicating tooling and observability.

## Specification and Implementation Details
As mentioned in the overview, the implementation is split across move framework and blockchain core.
### Move framework implementation
In the move framework 'ScheduledTransaction' and its corresponding 'TransactionId' are defined as below. TransactionId is computed using the SHA3-256 hash of the txn at the time the user schedules it—even in the case of recurring transactions.  This hash serves as a unique identifier for the ScheduledTransaction and is used to track and manage it throughout its lifecycle within the system.
```jsx
/// ScheduledTransaction with permission signer handle, scheduled_time, gas params, and function
    struct ScheduledTransaction has copy, drop, store {
        /// 72 bytes (32 + 32 + 8)
        sender_handle: StorablePermissionedHandle,
        /// 100ms granularity
        scheduled_time: u64,
        /// Maximum gas to spend for this transaction
        max_gas_amount: u64,
        /// Charged @ lesser of {max_gas_unit_price, max_gas_unit_price other than this in the block executed}
        max_gas_unit_price: u64,
        /// txn to be rescheduled at scheduled_time + next_schedule_delta_time.
        /// Note: (1) Once set, the txn will be rescheduled at the same delta interval next time, and so on.
        ///       (2) Can be cancelled, with the same id returned in insert(), to stop the perpetual rescheduling.
        ///       (3) If one rescheduled fails or is expired, the perpetual rescheduling chain will be broken.
        ///       (4) If scheduled_time + next_schedule_delta_time < current_time, the txn reschedule will fail.
        next_schedule_delta_time: u64,
        /// Variables are captured in the closure; no arguments passed; no return
        f: |()|
    }

    /// SHA3-256
    struct TransactionId has copy, drop, store {
        hash: vector<u8>
    }

```

Users can submit or cancel a ScheduledTransaction. These actions are restricted to the user identified by the sender_handle, ensuring that only the fee/deposit paying user has the authority to insert or cancel the transaction.
```jsx
    /// Insert a scheduled transaction into the queue. Txn_id is returned to user, which can be used to cancel the txn.
    public fun insert(sender: &signer, txn: ScheduledTransaction): vector<u8> {...}

    /// Cancel a scheduled transaction, must be called by the signer who originally scheduled the transaction.
    public fun cancel(sender: &signer, txn_id: vector<u8>)
```

Scheduled txns are stored in a BigOrderedMap sorted by execution time so that each block has to only look upto the txns it needs to run. And for quick lookup by TransactionId another BigOrderedMap is used.
```jsx
    /// First sorted in ascending order of time, then on gas priority, and finally on txn_id
    /// gas_priority = U64_MAX - gas_unit_price; we want higher gas_unit_price to come before lower gas_unit_price
    /// The goal is to have fixed size key, val entries in BigOrderedMap, hence we use txn_id as a key instead of
    /// having {time, gas_priority} --> List<txn_id>
    struct ScheduleMapKey has copy, drop, store {
        time: u64,
        gas_priority: u64,
        txn_id: TransactionId
    }

    /// Dummy struct to use as a value type in BigOrderedMap
    struct Empty has copy, drop, store {}

    struct ScheduleQueue has key {
        /// key_size = 48 bytes; value_size = 0
        schedule_map: BigOrderedMap<ScheduleMapKey, Empty>,
        /// lookup 'ScheduledTransaction' by txn_id
        /// Using a 'table' is costly because it creates a new slot for every <key, val>; hence using BigOrderedMap
        txn_tbl: BigOrderedMap<TransactionId, ScheduledTransaction>
    }
```

The framework also includes logic to retrieve transactions that are ready for execution. Because the ScheduleQueue is sorted by execution time, only the earliest segment of the queue needs to be scanned to find eligible transactions. Transactions that remain unexecuted for approximately 100 blocks (about 10 seconds) are considered expired and are removed from the ScheduleQueue. Note that the 'TransactionId' is passed around instead of re-computing it
```jsx
/// We pass the id around instead re-computing it
struct ScheduledTransactionWithId has copy, drop, store {
    txn: ScheduledTransaction,
    txn_id: TransactionId
}

/// Gets txns due to be run; also expire txns that could not be run for a while (mostly due to low gas priority)
    fun get_ready_transactions(timestamp: u64, limit: u64): vector<ScheduledTransactionWithId>
```

To store the gas fee deposit collected at the time of scheduling (or re-scheduling), we use a framework reserved account owned fa store.
```jsx
    // Create owner account for handling deposits
    let owner_addr = @0xb;
    let (owner_signer, owner_cap) =
    account::create_framework_reserved_account(owner_addr);

    // Initialize fungible store for the owner
    let metadata = ensure_paired_metadata<AptosCoin>();
    primary_fungible_store::ensure_primary_store_exists(
        signer::address_of(&owner_signer), metadata
    );

    /// Signer for the store for gas fee deposits
    struct GasFeeDepositStoreSignerCap has key {
        cap: account::SignerCapability
    }
```

At the beginning of the execution stage of every block ()

The actual gas fees are charged, and any excess deposit is refunded in the epilogue of the executed scheduled transaction. To preserve the ability to execute transactions in parallel during block execution via BlockSTM, the scheduled transaction is only marked for removal upon execution. Its actual removal from the ScheduleQueue takes place during the block prologue of the subsequent block.

### Blockchain core implementation
#### Getting ready transactions
{WIP}

#### Gas prioritization
{WIP}

## Reference Implementation
Framework PR: [aptos-labs/aptos-core/16346](https://github.com/aptos-labs/aptos-core/pull/16346)
Blockchain Core PR: {WIP}
 > What is the feature flag(s)? If there is no feature flag, how will this be enabled?
{WIP}

## Testing 
* Framework unit tests
* Blockchain core tests
* E2E tests
* Load tests
  *  Scheduled transactions do not slow down the TPS of regular execution.
* Scheduled Transactions Perf tests
  * We must be able to process atleast 100 (perhaps upto 1000) scheduled txns per block without slowing down the block.

## Risks and Drawbacks

* Express here the potential risks of taking on this proposal. What are the hazards? What can go wrong?
  * Hard to predict future gas markets, and hence guarentee effective gas prioritization
  * The 'best effort' of scheduling may not satisfy all kinds of user expectations
* Can this proposal impact backward compatibility?
  * No
* What is the mitigation plan for each risk or drawback?
  * We keep an ability to shutdown scheduled txns and refund deposit
  * Do we want an ability to temporarily pause the 'scheduled txns' feature ???

## Security Considerations

 > - How can this AIP potentially impact the security of the network and its users? How is this impact mitigated?
 > - Are there specific parts of the code that could introduce a security issue if not implemented properly?
 > - Link tests (e.g. unit, end-to-end, property, fuzz) in the reference implementation that validate both expected and unexpected behavior of this proposal
 > - Include any security-relevant documentation related to this proposal (e.g. protocols or cryptography specifications)

{WIP}

## Future Potential

We can build the below alongside or by directly extending Scheduled Transactions.
 * Event based triggers
 * Future execution gas markets
 *  * Guaranteed execution
 *  * Block Space Auctioning
 * Deterministic slicing

## Timeline

### Suggested implementation timeline

Q2 2025

...

### Suggested developer platform support timeline

 > **Optional:** Describe the plan to have SDK, API, CLI, Indexer support for this feature, if applicable. 

...

### Suggested deployment timeline

 > **Optional:** Indicate a future release version as a *rough* estimate for when the community should expect to see this deployed on our three networks (e.g., release 1.7).
 > You are responsible for updating this AIP with a better estimate, if any, after the AIP passes the gatekeeper’s design review.
 >
 > - On devnet?
 > - On testnet?
 > - On mainnet?

...


## Open Questions (Optional)

 > Q&A here, some of them can have answers some of those questions can be things we have not figured out, but we should

...
