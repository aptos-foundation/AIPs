---
aip: (this is determined by the AIP Manager, leave it empty when drafting)
title: Order Book (CLOB) Datastructure
author: igor-aptos, skedia, runtianz, brian
discussions-to (*optional): <a url pointing to the official discussion thread>
Status: Draft
last-call-end-date (*optional): <mm/dd/yyyy the last date to leave feedbacks and reviews>
type: Standard (Framework)
created: 03/01/2025
updated (*optional): <mm/dd/yyyy>
requires (*optional): <AIP number(s)>
---

# AIP-X - Order Book (CLOB) Datastructure
  
## Summary

Central limit order book (CLOB) is a core component for an order-book based exchange.  

This AIP is a proposal to implement an efficient and concurrent CLOB datastructure, that can be used by anyone that wants to implement a decentralized exchange.

Providing both efficient and concurrent CLOB, it allows exchanges to have onchain matching, allowing exchange to have full transparency on the matching decisions, without sacrificing performance.

Core compoenents of Aptos blockchain are uniquely suited for an onchain Order Book: very high consensus throughput and speculatively parallel transaction execution (via BlockSTM).
We will start with a pure move implementation, and then based on benchmarking, improve it as appropriate - potentially via moving components of it to native code, allowing for exploiting higher concurrency that BlockSTM allows (like aggregators did), or to make the critical path more efficient (as we recently did with vector and other datastructures). 
Aptos blockchain is uniquely positioned 

### Out of scope

- Fully functional exchange
- Global order book

## High-level Overview

CLOB has two components:
- active order book, tracking all currently active/executable limit orders, and providing matching when new active orders are placed
- pending order book, keeping track of conditional order types - like TP/SL, TWAP, etc, and moving them to active order book as needed.

We will provide the interfaces, and iterate on the implementation. Until interfaces and implementation are finalized, OrderBook will live in framework-experimental (0x7) - which is deployed to local networks / devnet alone. 

## Impact

- Anyone who wants to build a high-throughput DEX

## Alternative Solutions

Keeping CLOB on the ecosystem to implement, might not allow for all the optimizations that can be done with tight integration with the VM/BlockSTM.

## Specification and Implementation Details

Current wip of the main API to the `OrderBook`, looks as follows:

```
    struct OrderBook<M: store + copy + drop> has store;

    struct SingleOrderMatch<M: store + copy + drop> has drop, copy {
        order: Order<M>,
        matched_size: u64
    }

    public fun new_order_request<M: store + copy + drop>(
        account: address,
        account_order_id: u64,
        unique_priority_idx: Option<UniqueIdxType>,
        price: u64,
        orig_size: u64,
        remaining_size: u64,
        is_buy: bool,
        trigger_condition: Option<TriggerCondition>,
        metadata: M
    ): OrderRequest<M>;

    public fun place_maker_order<M: store + copy + drop>(
        self: &mut OrderBook<M>, order_req: OrderRequest<M>
    ): bool;

    public fun get_single_match_for_taker<M: store + copy + drop>(
        self: &mut OrderBook<M>,
        price: u64,
        size: u64,
        is_buy: bool
    ): SingleOrderMatch<M>;

    public fun is_taker_order<M: store + copy + drop>(
        self: &OrderBook<M>,
        price: u64,
        is_buy: bool,
        trigger_condition: Option<TriggerCondition>
    ): bool;

    public fun trigger_next_conditional_order(
        self: &OrderBook<M>, 
        oracle_price: u64,
    ) 

    # market price and depth related API 

    # call to provide oracle price and timestamp to trigger pending orders

```

Dex would then need to implement all logic of storing the OrderBook struct onchain, and placing orders into the OrderBook, and handling actual trade of assets when matches are found.


## Reference Implementation

TBD

## Testing 

We will measure performance:
- of a single trading pair order book, against variety of conditions:
  - varying levels of match %, num of orders per match, spread of prices users will use
- having multiple trading pairs

## Risks and Drawbacks

- Adding complexity to the Framework 

## Security Considerations

It's a DataStructure, so only security concerns are that there are no bugs, and that behaviour is clearly documented, for the correct implementation of the whole exchange

## Future Potential

Further financial primitives can be implemented, allowing for richer financial markets on Aptos.

## Timeline

### Suggested implementation timeline

TBD

### Suggested developer platform support timeline

TBD

### Suggested deployment timeline

TBD
First versions on devnet in ~ Apr / May 2025
