---
aip: 36
title: Universally Unique Identifiers
authors: satya@aptoslabs.com, ikabiljo@aptoslabs.com
discussions-to (*optional): https://github.com/aptos-foundation/AIPs/issues/154
Status: Draft
type: Standard
created: 06/01/2023
---

# AIP 36 - Universally Unique Identifiers

## Summary

This AIP proposes to add a new native function create_uuid in Aptos framework that generates and outputs a unique 256-bit identifier (of type address) for each function call. The create_uuid function calls can run efficiently and in parallel. In other words, when two transactions run create_uuid method, they can be executed in parallel without any conflicts. Initially, we will use these unique identifiers internally as addresses for newly created Move Objects.

## Motivation

There is a general need to be able to create unique identifiers or addresses. There is no such utility in Move today, and so various alternatives have been used, which bring performance implications. We want to provide such an utility for all usecases that needed it.

Concretely, when a new object is created, we need to associate it with a unique address. For named objects, we deterministically derive it from the name. But for all other objects, we currently derive it from a GUID (Globally Unique Identifier) that we create on the fly. A GUID consists of a tuple `(address, creation_num)`. We create GUID by having `address` be the account address of the object or resource’s creator, and the `creation_num` is the guid sequence number of the object or resource created by that account. As the sequence number `creation_num` has to be incremented for each object/resource creation, GUID generation is inherently sequential, within the same address. As an example, in Token V2 whenever a new token is minted using `token::create_from_account`, object is created to back it, which uses GUID generated based on the collection address, and so all such mints from the same collection are inherently sequential.

This AIP thereby creates a new type of identifier called UUID (Universally Unique Identifier). This is a 256-bit identifier that is universally unique amongst all the identifiers generated by all the accounts for all purposes. We propose adding a new native function `create_uuid` in Aptos framework. Every time a MOVE code calls `create_uuid`, the function outputs a universally unique 256-bit value.

## Specification

The Aptos Framework contains a `transaction_context` module, which can be used by MOVE modules to retrieve information related to the current transaction being executed. When a transaction is executed, the session first creates a context. The context contains, amongst other things, `NativeTransactionContext` . The `transaction_context` module provides an API interface to answer questions on `NativeTransactionContext` . 

For this AIP, when a session is created, we will store the transaction hash in the `NativeTransactionContext`. We will additionally store a `uuid_counter` in the context and initiate the counter to 0. We will add a native function called `create_uuid` in `transaction_context` module. When called, the `create_uuid` function will first increment the `uuid_counter` and outputs a value in the below format

```
output identifier = SHA256(0xFB || txn_hash || uuid_counter)
```

`0xFB`is prepended to SHA256 input for domain separation, in case the same mechanism has to be used to create identifiers for other purposes. Formula is equivalent to how output identifier is created from Guid(txn_hash, uuid_counter) in the 0xFB namespace.

Each user transaction contains a the sender’s account information and sequence number that is incremented for each transaction. Each BlockMetadata transaction has epoch and round number. This means each transaction accepted by Aptos consensus has unique set of bytes, and so produces unique txn_hash (assuming no SHA256 collisions).

## Alternatives

Another alternative to the above create_uuid function, is to add a get_txn_hash native function to transaction_context module. The function simply outputs the transaction hash of the current transaction being executed. Anyone who wishes to generate unique identifiers can then implement the above mechanism by themselves. 

## Reference Implementation

This feature is currently implemented in the PR https://github.com/aptos-labs/aptos-core/pull/8401.

## Risks and Drawbacks

Above function produces unique identifiers that have no collisions within them (given no SHA256 collisions), or across other ways to generate unique addresses - like all current GUID flows. But it isn’t “attacker-proof” (neither are the current GUID flows), i.e. if someone knows transaction hash, it can front-run and create a transaction that knows that object address. So in order to guarantee no collisions, scoping of who can create resources and not allowing input addresses can provide such guarantee. (i.e. `object.move` doesn’t provide a function to create an object at a given input address, it always internally computes it).

Generated identifiers are random-looking, and only way to retrieve them later is to store their address from where you need to access them (or use events during indexing for of chain analysis). In contrast, creating uuids from names is a repeatable process, and can be looked up later without indexing of the handle. For this reason, at this time, we are replacing all functions within `object.move` except for `create_named_object` to use above utility.
