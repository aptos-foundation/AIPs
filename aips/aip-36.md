---
aip: 36
title: Universally Unique Identifiers
authors: satya@aptoslabs.com, ikabiljo@aptoslabs.com
discussions-to (*optional): https://github.com/aptos-foundation/AIPs/issues/154
Status: Draft
type: Standard
created: 06/01/2023
---

# AIP 36 - Universally Unique Identifiers

## Summary

This AIP proposes to add two new native functions `create_unique_address` and `get_txn_hash` in Aptos framework. The `create_unique_address` generates and outputs a unique 256-bit identifier (of type address) for each function call. The `get_txn_hash` function outputs the hash of the current transaction. The `create_unique_address` function calls can run efficiently and in parallel. In other words, when two transactions run `create_unique_address` method, they can be executed in parallel without any conflicts. Initially, we will use these unique identifiers internally as addresses for newly created Move Objects.

## Motivation

There is a general need to be able to create unique identifiers or addresses. There is no such utility in Move today, and so various alternatives have been used, which bring performance implications. We want to provide such an utility for all usecases that needed it.

Concretely, when a new object is created, we need to associate it with a unique address. For named objects, we deterministically derive it from the name. But for all other objects, we currently derive it from a GUID (Globally Unique Identifier) that we create on the fly. A GUID consists of a tuple `(address, creation_num)`. We create GUID by having `address` be the account address of the object or resource’s creator, and the `creation_num` is the guid sequence number of the object or resource created by that account. As the sequence number `creation_num` has to be incremented for each object/resource creation, GUID generation is inherently sequential, within the same address. As an example, in Token V2 whenever a new token is minted using `token::create_from_account`, object is created to back it, which uses GUID generated based on the collection address, and so all such mints from the same collection are inherently sequential.

This AIP thereby creates a new type of identifier called UUID (Universally Unique Identifier). This is a 256-bit identifier that is universally unique amongst all the identifiers generated by all the accounts for all purposes. We propose adding two native functions `create_unique_address` and `get_txn_hash` in Aptos framework. Every time a MOVE code calls `create_unique_address`, the function outputs a universally unique 256-bit value (of type `address`). The function creates a unique address by using the hash of the current transaction. As exposing the transaction hash might have more applications in the future, we also propose to add the `get_txn_hash` function which returns the hash of the current transaction.

## Specification

The Aptos Framework contains a `transaction_context` module, which can be used by MOVE modules to retrieve information related to the current transaction being executed. When a transaction is executed, the session first creates a context. The context contains, amongst other things, `NativeTransactionContext` . The `transaction_context` module provides an API interface to answer questions on `NativeTransactionContext` . 

For this AIP, when a session is created, we will store the transaction hash in the `NativeTransactionContext`. We will additionally store a `uuid_counter` in the context and initiate the counter to 0. We will add a native function called `create_unique_address` in `transaction_context` module. When called, the `create_unique_address` function will first increment the `uuid_counter` and outputs a value in the below format

```
output identifier = SHA3-256(txn_hash || uuid_counter || 0xFB)
```

`0xFB`is appended to SHA3-256 input for domain separation, in case the same mechanism has to be used to create identifiers for other purposes. Formula is equivalent to how output identifier is created from Guid(txn_hash, uuid_counter) in the 0xFB namespace.

Each user transaction contains the sender’s account information and sequence number that is incremented for each transaction. Each `BlockMetadata` transaction has epoch and round number. This means each transaction accepted by Aptos consensus has unique set of bytes, and so produces unique transaction hash (assuming no SHA3-256 collisions).

## Alternatives

Another alternative to the above `create_unique_address` function, is to expose only the `get_txn_hash` native function. Anyone who wishes to generate unique identifiers can then implement the above mechanism by themselves.

## Reference Implementation

This feature is currently implemented in the PR https://github.com/aptos-labs/aptos-core/pull/8401.

## Notes

Above function produces unique identifiers that have no collisions within them (given no SHA3-256 collisions), or across other ways to generate unique addresses - like all current GUID flows. But it isn’t “attacker-proof” (neither are the current GUID flows), i.e. if someone knows transaction hash, it can front-run and create a transaction that knows that object address. So in order to guarantee no collisions, scoping of who can create resources and not allowing input addresses can provide such guarantee. (i.e. `object.move` doesn’t provide a function to create an object at a given input address, it always internally computes it).

Generated identifiers are random-looking, and only way to retrieve them later is to store their address from where you need to access them (or use events during indexing for of chain analysis). In contrast, creating uuids from names is a repeatable process, and can be looked up later without indexing of the handle. For this reason, at this time, we are replacing all functions within `object.move` except for `create_named_object` to use above utility.
